name: Deploy to Staging

on:
  push:
    branches:
      - main
      - develop
  workflow_dispatch:
    inputs:
      version:
        description: 'Docker image version to deploy'
        required: false
        default: 'latest'

env:
  NAMESPACE: todo-app-staging
  HELM_RELEASE: todo-app-staging
  CLUSTER_NAME: todo-app-staging-cluster

jobs:
  deploy-staging:
    name: Deploy to Staging Environment
    runs-on: ubuntu-latest
    environment:
      name: staging
      url: https://staging.todoapp.example.com

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Set up Helm
        uses: azure/setup-helm@v3
        with:
          version: 'v3.13.0'

      # Azure AKS Authentication
      - name: Azure Login
        if: ${{ vars.CLOUD_PROVIDER == 'azure' }}
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Set AKS Context
        if: ${{ vars.CLOUD_PROVIDER == 'azure' }}
        uses: azure/aks-set-context@v3
        with:
          resource-group: ${{ secrets.AZURE_RESOURCE_GROUP }}
          cluster-name: ${{ env.CLUSTER_NAME }}

      # Google GKE Authentication
      - name: Authenticate to Google Cloud
        if: ${{ vars.CLOUD_PROVIDER == 'gcp' }}
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}

      - name: Set GKE Context
        if: ${{ vars.CLOUD_PROVIDER == 'gcp' }}
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.CLUSTER_NAME }}
          location: ${{ secrets.GCP_REGION }}

      # Oracle OKE Authentication
      - name: Set OKE Context
        if: ${{ vars.CLOUD_PROVIDER == 'oracle' }}
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > ~/.kube/config
          chmod 600 ~/.kube/config

      - name: Verify cluster connection
        run: |
          kubectl cluster-info
          kubectl get nodes

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Create Docker registry secret
        run: |
          kubectl create secret docker-registry regcred \
            --docker-server=${{ secrets.DOCKER_REGISTRY }} \
            --docker-username=${{ secrets.DOCKER_USERNAME }} \
            --docker-password=${{ secrets.DOCKER_PASSWORD }} \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create database secret
        run: |
          kubectl create secret generic postgres-secret \
            --from-literal=connection-string="${{ secrets.STAGING_DATABASE_URL }}" \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Create JWT secret
        run: |
          kubectl create secret generic jwt-secret \
            --from-literal=jwt-secret-key="${{ secrets.STAGING_JWT_SECRET }}" \
            --namespace=${{ env.NAMESPACE }} \
            --dry-run=client -o yaml | kubectl apply -f -

      - name: Determine image tag
        id: image_tag
        run: |
          if [ "${{ github.event.inputs.version }}" != "" ]; then
            echo "tag=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "tag=${{ github.sha }}" >> $GITHUB_OUTPUT
          fi

      - name: Deploy with Helm
        run: |
          helm upgrade --install ${{ env.HELM_RELEASE }} ./k8s/helm-charts/todo-app \
            --namespace ${{ env.NAMESPACE }} \
            --values ./k8s/helm-charts/todo-app/values-cloud.yaml \
            --set global.environment=staging \
            --set global.imageRegistry=${{ secrets.DOCKER_REGISTRY }} \
            --set chatApi.image.tag=${{ steps.image_tag.outputs.tag }} \
            --set recurringTasks.image.tag=${{ steps.image_tag.outputs.tag }} \
            --set notifications.image.tag=${{ steps.image_tag.outputs.tag }} \
            --set audit.image.tag=${{ steps.image_tag.outputs.tag }} \
            --set frontend.image.tag=${{ steps.image_tag.outputs.tag }} \
            --set ingress.hosts[0].host=staging.todoapp.example.com \
            --set ingress.hosts[1].host=api-staging.todoapp.example.com \
            --wait \
            --timeout 10m

      - name: Wait for pods to be ready
        run: |
          kubectl wait --for=condition=ready pod \
            -l "app in (chat-api,recurring-tasks,notifications,audit,frontend)" \
            -n ${{ env.NAMESPACE }} \
            --timeout=300s

      - name: Run health checks
        id: health_check
        run: |
          # Chat API health check
          kubectl run healthcheck-${{ github.run_id }} \
            --image=curlimages/curl:latest \
            --restart=Never \
            --namespace=${{ env.NAMESPACE }} \
            --rm -i --quiet -- \
            curl -f -s http://chat-api:8000/health || exit 1

      - name: Get deployment status
        run: |
          echo "### Staging Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** Staging" >> $GITHUB_STEP_SUMMARY
          echo "**Image Tag:** ${{ steps.image_tag.outputs.tag }}" >> $GITHUB_STEP_SUMMARY
          echo "**Namespace:** ${{ env.NAMESPACE }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployed at:** $(date -u +"%Y-%m-%d %H:%M:%S UTC")" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "#### Pod Status" >> $GITHUB_STEP_SUMMARY
          kubectl get pods -n ${{ env.NAMESPACE }} -o wide >> $GITHUB_STEP_SUMMARY

      - name: Run smoke tests
        run: |
          echo "Running smoke tests against staging environment..."
          # Add your smoke test commands here
          # Example: curl https://api-staging.todoapp.example.com/health

      - name: Notify success
        if: success()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "Staging deployment successful! :rocket:",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Staging Deployment Successful* :white_check_mark:\n*Environment:* Staging\n*Image Tag:* ${{ steps.image_tag.outputs.tag }}\n*Branch:* ${{ github.ref_name }}\n*Commit:* ${{ github.sha }}\n*Deployed by:* ${{ github.actor }}"
                  }
                },
                {
                  "type": "actions",
                  "elements": [
                    {
                      "type": "button",
                      "text": {
                        "type": "plain_text",
                        "text": "View Staging"
                      },
                      "url": "https://staging.todoapp.example.com"
                    }
                  ]
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        continue-on-error: true

      - name: Rollback on failure
        if: failure()
        run: |
          echo "Deployment failed! Rolling back to previous version..."
          helm rollback ${{ env.HELM_RELEASE }} -n ${{ env.NAMESPACE }} || true

      - name: Notify failure
        if: failure()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "Staging deployment failed! :x:",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Staging Deployment Failed* :x:\n*Environment:* Staging\n*Image Tag:* ${{ steps.image_tag.outputs.tag }}\n*Branch:* ${{ github.ref_name }}\n*Commit:* ${{ github.sha }}\n*Deployed by:* ${{ github.actor }}\n\n*Action:* Automatically rolled back"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        continue-on-error: true
